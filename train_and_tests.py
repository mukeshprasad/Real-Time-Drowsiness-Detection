# -*- coding: utf-8 -*-
"""Train and Tests.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nzSVUks7yEp7crMuxUG13CD1ULzfhlrO

#### **Importing neccessary libraries and modules**
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import numpy as np
import matplotlib.pyplot as plt
import cv2
import os

"""#### **Initial verification of the dataset**"""

os.listdir('drive/MyDrive/Drowsy/Dataset')  # Checking Availability of Dataset

img_array = cv2.imread("drive/MyDrive/Drowsy/Dataset/Closed/s0001_00001_0_0_0_0_0_01.png", cv2.IMREAD_GRAYSCALE)
plt.imshow(img_array, cmap="gray")
print(img_array.shape)

"""#### **Data Pre-processing, Transformation and Creating Training Data**"""

DATA_DIRECTORY = "drive/MyDrive/Drowsy/Dataset/"
classes = ['Closed', 'Open']
training_data = []
img_size = 224

def create_training_data():
    for category in classes:
        path = os.path.join(DATA_DIRECTORY, category)
        class_num = classes.index(category)
        for img in os.listdir(path):
            try:
                img_array = cv2.imread(os.path.join(path, img), cv2.IMREAD_GRAYSCALE)
                back_to_rgb = cv2.cvtColor(img_array, cv2.COLOR_GRAY2RGB)
                new_array = cv2.resize(back_to_rgb, (img_size, img_size))
                training_data.append([new_array, class_num])
            except Exception as e:
                print("Exception Found" + e)

create_training_data()

len(training_data)

import random
random.shuffle(training_data)

# Data and labels
X, Y = [], []

for feature, label in training_data:
    X.append(feature)
    Y.append(label)

# Creating NumPy Arrays of Data and Label
X = np.array(X).reshape(-1, img_size, img_size, 3)
X = X / 255.0 # Normalizing

Y = np.array(Y)

print(X.shape, Y.shape)

# pickling for future purposes

import pickle

pickle_out = open("x.pickle", "wb")
pickle.dump(X, pickle_out)
pickle_out.close()

pickle_out = open("y.pickle", "wb")
pickle.dump(Y, pickle_out)
pickle_out.close()

# Loading the pickled data

pickle_in = open("x.pickle", "rb")
X = pickle.load(pickle_in)

pickle_in = open("y.pickle", "rb")
Y = pickle.load(pickle_in)

"""### **Building Deep Learning Model - Transfer Learning**"""

from tensorflow import keras
from tensorflow.keras import layers

model = tf.keras.applications.mobilenet.MobileNet()

model.summary()

## Transfer Learning

base_input = model.layers[0].input
base_output = model.layers[-4].output

flat_layer = layers.Flatten()(base_output)
final_output = layers.Dense(1)(flat_layer)
final_output = layers.Activation('sigmoid')(final_output)

my_model = keras.Model(inputs=base_input, outputs=final_output)

my_model.summary()

my_model.compile(loss="binary_crossentropy", optimizer="adam", metrics=["accuracy"])

"""### **Training, Fitting the Model and Validation**"""

history1 = my_model.fit(X, Y, epochs=10, verbose=1, validation_split=0.2)

"""### **Visualizing the Performance of the Model:**

#### **1. Training Accuracy vs Validation Accuracy:**
"""

acc = history1.history['accuracy']
val_acc = history1.history['val_accuracy']

# Plotting

plt.figure(figsize=(8, 8))
plt.subplot(2, 1, 1)
plt.plot(acc, label='Training Accuracy')
plt.plot(val_acc, label='Validation Accuracy')
plt.legend(loc='lower right')
plt.ylabel('Accuracy')
plt.ylim([min(plt.ylim()),1])
plt.title('Training and Validation Accuracy')

"""#### **2. Training Loss vs Validation Loss:**"""

loss = history1.history['loss']
val_loss = history1.history['val_loss']

# Plotting

plt.subplot(2, 1, 2)
plt.plot(loss, label='Training Loss')
plt.plot(val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.ylabel('Cross Entropy')
plt.ylim([0,max(plt.ylim())])
plt.title('Training and Validation Loss')
plt.show()

"""### **Save Model:**"""

my_model.save('train_dd.h5')

"""### **Testing on Dataset:**"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
import cv2


model = tf.keras.models.load_model('drive/MyDrive/Collection/train_dd.h5')

def predict_single_eye(path):
    ''' Enter the path of the image'''
    img_size = 224
    img_array = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    # plt.imshow(img_array)
    back_to_rgb = cv2.cvtColor(img_array, cv2.COLOR_GRAY2RGB)
    new_array = cv2.resize(back_to_rgb, (img_size, img_size))

    x_input = np.array(new_array).reshape(1, img_size, img_size, 3)
    x_input = x_input / 255.0

    plt.imshow(cv2.cvtColor(new_array, cv2.COLOR_BGR2RGB))
    prediction = model.predict(x_input)

    if prediction < 0.7:
        pred = f'Drowsy - Closed Eye - {np.around(100*(1 - prediction[0][0]), 4)} accuracy'
    else:
        pred = f'Active - Open Eye - {np.around(100*(prediction[0][0]), 4)} accuracy'

    return pred, prediction

predict_single_eye('drive/MyDrive/Drowsy/Dataset/Closed/s0001_00003_0_0_0_0_0_01.png')

predict_single_eye('drive/MyDrive/Drowsy/Dataset/Open/s0001_01842_0_0_1_0_0_01.png')

"""### **Testing on Random Inputs:**

#### **Single Eye Image:**
"""

def predict_single_eye(path):
    ''' Enter the path of the image'''
    img_size = 224
    img_array = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    # plt.imshow(img_array)
    back_to_rgb = cv2.cvtColor(img_array, cv2.COLOR_GRAY2RGB)
    new_array = cv2.resize(back_to_rgb, (img_size, img_size))

    x_input = np.array(new_array).reshape(1, img_size, img_size, 3)
    x_input = x_input / 255.0

    plt.imshow(cv2.cvtColor(new_array, cv2.COLOR_BGR2RGB))
    prediction = model.predict(x_input)

    if prediction < 0.7:
        pred = f'Drowsy - Closed Eye - {np.around(100*(1 - prediction[0][0]), 4)} accuracy'
    else:
        pred = f'Active - Open Eye - {np.around(100*(prediction[0][0]), 4)} accuracy'

    return pred, prediction

predict_single_eye('single_close.png')

predict_single_eye('single_open.png')

"""#### **Complete Image/Face:**"""

lefteye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_lefteye_2splits.xml')
righteye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_righteye_2splits.xml')

def predict_full_image(path):
    ''' Takes in the path of the image to predict'''

    img = cv2.imread(path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # eyes = eye_cascade.detectMultiScale(gray, 1.1, 4)

    left_eyes = lefteye_cascade.detectMultiScale(img)
    right_eyes = righteye_cascade.detectMultiScale(img)
    all_eyes = [*left_eyes, *right_eyes]

    if left_eyes == () and right_eyes == ():
        print("Eyes not detected")
    else:
        print(len(all_eyes))
        preds = []
        img_size = 224
        for i, (x,y,w,h) in enumerate(all_eyes):
            print(i, (x, y, w, h))
            roi_gray = gray[y:y+h, x:x+w]
            roi_color = img[y:y+h, x:x+w]
            plt.imshow(cv2.cvtColor(roi_color, cv2.COLOR_BGR2RGB))
            new_array = cv2.resize(roi_color, (img_size, img_size))

            x_input = np.array(new_array).reshape(1, img_size, img_size, 3)
            x_input = x_input / 255.0

            prediction = model.predict(x_input)
            preds += prediction,
        
        if any(p < 0.9 for p in preds):
            print('DROWSY')
        else:
            print('ACTIVE')

predict_full_image('1_closed_complete.jpg')

predict_full_image('2_closed_complete.jpg')

predict_full_image('1_open_complete.jpg')

predict_full_image('2_open_complete.jpg')